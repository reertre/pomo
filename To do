#!/usr/bin/env bash
#
# rename_files_and_folders_separately.sh
#
# 1) Renames files (only)
# 2) Renames directories (only)
#
# Replaces OLD_CHG with CHG, and OLD_RELEASE with RELEASE_VERSION.

set -e

echo "===== Starting Separate Renames ====="
echo "Current directory: $(pwd)"
echo "Contents before rename:"
ls -al

# --- CONFIGURATION ---
OLD_CHG="CHG99999999999"
CHG="CHG165890"

OLD_RELEASE="release_99.9"
RELEASE_VERSION="v15.0"

echo "Configuration:"
echo "  OLD_CHG=$OLD_CHG  ->  CHG=$CHG"
echo "  OLD_RELEASE=$OLD_RELEASE  ->  RELEASE_VERSION=$RELEASE_VERSION"

# -----------------------------------------------------------------------------
# 1) Rename Files
# -----------------------------------------------------------------------------
echo "----- Renaming Files Only -----"
find . -type f -depth | while IFS= read -r file; do
  # Generate the new file path by replacing the old patterns
  newfile="$(echo "$file" | sed -e "s/${OLD_CHG}/${CHG}/g" -e "s/${OLD_RELEASE}/${RELEASE_VERSION}/g")"

  # Only rename if it actually changed
  if [ "$file" != "$newfile" ]; then
    echo "Renaming file: '$file' -> '$newfile'"
    mv "$file" "$newfile"
  fi
done

# -----------------------------------------------------------------------------
# 2) Rename Directories
# -----------------------------------------------------------------------------
echo "----- Renaming Directories Only -----"
# We do directories in a separate pass. Using -depth ensures we rename
# deeper directories before their parents (avoiding conflicts).
find . -type d -depth | while IFS= read -r dir; do
  newdir="$(echo "$dir" | sed -e "s/${OLD_CHG}/${CHG}/g" -e "s/${OLD_RELEASE}/${RELEASE_VERSION}/g")"

  if [ "$dir" != "$newdir" ]; then
    echo "Renaming directory: '$dir' -> '$newdir'"
    mv "$dir" "$newdir"
  fi
done

echo "===== Renaming Complete ====="
echo "Contents after rename:"
ls -al